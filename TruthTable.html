<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Boolean Logic Truth Table Generator</title>
    <style>
        /* CSS styles */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        h1 {
            text-align: center;
        }

        #input-area {
            text-align: center;
            margin-bottom: 10px;
        }

        #expression-input, #expression2-input {
            width: 80%;
            padding: 10px;
            font-size: 16px;
            margin-bottom: 10px;
        }

        #operator-buttons {
            text-align: center;
            margin-bottom: 20px;
        }

        .operator-button {
            padding: 5px 10px;
            font-size: 18px;
            margin: 0 5px;
            cursor: pointer;
        }

        #generate-button {
            padding: 10px 20px;
            font-size: 16px;
        }

        #truth-table {
            margin: 0 auto;
            border-collapse: collapse;
            width: 100%;
            max-width: 1000px;
        }

        #truth-table th, #truth-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        #truth-table th {
            background-color: #f2f2f2;
        }

        #truth-table .difference {
            background-color: #ffdddd;
        }

        #error-message {
            color: red;
            text-align: center;
        }

        #equivalence-message {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
            font-weight: bold;
        }

        footer {
            margin-top: 20px;
            text-align: center;
            font-size: 14px;
            color: #555;
        }

        /* Footer link styling */
        footer a {
            color: #555;
            text-decoration: none;
            font-weight: bold;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Toggle switch styling */
        .toggle-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .toggle-container label {
            margin-right: 10px;
            font-size: 16px;
        }

        /* Highlight focused input field */
        input:focus {
            border-color: #66afe9;
            outline: none;
        }

    </style>
</head>
<body>
<h1>Boolean Logic Truth Table Generator</h1>
<div id="input-area">
    <div class="toggle-container">
        <label>
            <input type="radio" name="mode" value="single" checked> Single Expression Mode
        </label>
        <label>
            <input type="radio" name="mode" value="double"> Double Expression Mode
        </label>
    </div>
    <div>
        <input type="text" id="expression-input" placeholder="Enter Boolean Expression (e.g., (~(A v B)) -> (~A ⋅ ~B))" />
    </div>
    <div id="expression2-container" style="display: none;">
        <input type="text" id="expression2-input" placeholder="Enter Second Boolean Expression (e.g., (~A) v (~B))" />
    </div>
    <div id="operator-buttons">
        <button class="operator-button" data-operator="v">v (OR)</button>
        <button class="operator-button" data-operator="⋅">⋅ (AND)</button>
        <button class="operator-button" data-operator="~">~ (NOT)</button>
        <button class="operator-button" data-operator="->">-> (Conditional)</button>
        <button class="operator-button" data-operator="<->"><-> (Biconditional)</button>
        <button class="operator-button" data-operator="(">(</button>
        <button class="operator-button" data-operator=")">)</button>
    </div>
    <button id="generate-button">Generate Truth Table</button>
</div>
<div id="error-message"></div>
<div id="table-container">
    <!-- Truth table will be inserted here -->
</div>
<div id="equivalence-message"></div>

<footer>
    Generated by ChatGPT &middot; <a href="https://chatgpt.com/share/66e5f2be-a1f4-800a-a544-1b41db24f8bd" target="_blank" rel="noopener">View Session</a>
</footer>

<script>
    // Parser code

    // Boolean Logic Parser

    function tokenize(input) {
        const tokens = [];
        let i = 0;

        while (i < input.length) {
            const char = input[i];

            // Skip whitespace
            if (/\s/.test(char)) {
                i++;
                continue;
            }

            // Multi-character operators
            if (input.slice(i, i + 3) === '<->') {
                tokens.push({ type: 'BICONDITIONAL', value: '<->' });
                i += 3;
                continue;
            }
            if (input.slice(i, i + 2) === '->') {
                tokens.push({ type: 'CONDITIONAL', value: '->' });
                i += 2;
                continue;
            }

            // Single-character tokens
            switch (char) {
                case '~':
                    tokens.push({ type: 'NOT', value: '~' });
                    i++;
                    break;
                case '⋅':
                    tokens.push({ type: 'AND', value: '⋅' });
                    i++;
                    break;
                case 'v':
                    tokens.push({ type: 'OR', value: 'v' });
                    i++;
                    break;
                case '(':
                    tokens.push({ type: 'LPAREN', value: '(' });
                    i++;
                    break;
                case ')':
                    tokens.push({ type: 'RPAREN', value: ')' });
                    i++;
                    break;
                default:
                    // Identifiers (variables) - Only single capital letters A-Z
                    if (/[A-Z]/.test(char)) {
                        tokens.push({ type: 'IDENTIFIER', value: char });
                        i++;
                    } else {
                        throw new Error(`Invalid character at position ${i}: '${char}'. Variables must be single capital letters A-Z.`);
                    }
            }
        }

        return tokens;
    }

    // Parser

    function parse(input) {
        const tokens = tokenize(input);
        let current = 0;

        function parseExpression() {
            // Implicitly add parentheses around the entire expression
            return parseOperatorExpression();
        }

        function parseOperatorExpression() {
            let node = parseNotExpression();

            while (match('AND', 'OR', 'CONDITIONAL', 'BICONDITIONAL')) {
                const operator = previous();
                const right = parseNotExpression();
                node = {
                    type: getExpressionType(operator.type),
                    operator: operator.value,
                    left: node,
                    right: right,
                };
            }

            return node;
        }

        function parseNotExpression() {
            if (match('NOT')) {
                const operator = previous();
                const operand = parseNotExpression();
                return {
                    type: 'NotExpression',
                    operator: operator.value,
                    operand: operand,
                };
            }

            return parsePrimary();
        }

        function parsePrimary() {
            if (match('IDENTIFIER')) {
                return {
                    type: 'Identifier',
                    name: previous().value,
                };
            }

            if (match('LPAREN')) {
                const expr = parseOperatorExpression();
                consume('RPAREN', "Expect ')' after expression.");
                return expr;
            }

            throw new Error(`Unexpected token: ${peek().type} ('${peek().value}')`);
        }

        // Helper functions

        function getExpressionType(tokenType) {
            switch (tokenType) {
                case 'AND':
                    return 'AndExpression';
                case 'OR':
                    return 'OrExpression';
                case 'CONDITIONAL':
                    return 'ConditionalExpression';
                case 'BICONDITIONAL':
                    return 'BiconditionalExpression';
                default:
                    throw new Error('Unknown operator: ' + tokenType);
            }
        }

        function match(...types) {
            if (isAtEnd()) return false;
            for (let i = 0; i < types.length; i++) {
                if (check(types[i])) {
                    advance();
                    return true;
                }
            }
            return false;
        }

        function consume(type, message) {
            if (check(type)) return advance();
            throw new Error(message);
        }

        function check(type) {
            if (isAtEnd()) return false;
            return peek().type === type;
        }

        function advance() {
            if (!isAtEnd()) current++;
            return previous();
        }

        function isAtEnd() {
            return current >= tokens.length;
        }

        function peek() {
            return tokens[current];
        }

        function previous() {
            return tokens[current - 1];
        }

        const result = parseExpression();

        if (!isAtEnd()) {
            throw new Error('Unexpected token at the end of input: ' + peek().value);
        }

        return result;
    }

    // Helper function to convert AST node back to string
    function nodeToString(node) {
        switch (node.type) {
            case 'Identifier':
                return node.name;
            case 'NotExpression':
                return '~' + nodeToString(node.operand);
            case 'AndExpression':
            case 'OrExpression':
            case 'ConditionalExpression':
            case 'BiconditionalExpression':
                const left = nodeToString(node.left);
                const right = nodeToString(node.right);
                const operator = node.operator;
                return '(' + left + ' ' + operator + ' ' + right + ')';
            default:
                throw new Error('Unknown node type: ' + node.type);
        }
    }

    // Function to collect variables from AST in order
    function collectVariables(node, variables) {
        switch (node.type) {
            case 'Identifier':
                if (!variables.includes(node.name)) {
                    variables.push(node.name);
                }
                break;
            case 'NotExpression':
                collectVariables(node.operand, variables);
                break;
            case 'AndExpression':
            case 'OrExpression':
            case 'ConditionalExpression':
            case 'BiconditionalExpression':
                collectVariables(node.left, variables);
                collectVariables(node.right, variables);
                break;
            default:
                throw new Error('Unknown node type: ' + node.type);
        }
    }

    // Function to generate all possible truth assignments in the desired order
    function generateTruthAssignments(variables) {
        const numVars = variables.length;
        const numAssignments = Math.pow(2, numVars);
        const assignments = [];

        for (let i = 0; i < numAssignments; i++) {
            const assignment = {};
            for (let j = 0; j < numVars; j++) {
                const varIndex = numVars - j - 1; // Reverse variable order for correct bit significance
                const bit = (i >> j) & 1;
                assignment[variables[varIndex]] = bit === 1;
            }
            assignments.push(assignment);
        }

        return assignments.reverse();
    }

    // Function to evaluate the expression and collect subexpressions
    function evaluate(node, variableAssignment, subexpressionValues, subexpressions, variablesSet) {
        let result;

        switch (node.type) {
            case 'Identifier':
                result = variableAssignment[node.name];
                break;
            case 'NotExpression':
                const operandValue = evaluate(node.operand, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                result = !operandValue;
                break;
            case 'AndExpression':
                const leftAndValue = evaluate(node.left, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                const rightAndValue = evaluate(node.right, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                result = leftAndValue && rightAndValue;
                break;
            case 'OrExpression':
                const leftOrValue = evaluate(node.left, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                const rightOrValue = evaluate(node.right, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                result = leftOrValue || rightOrValue;
                break;
            case 'ConditionalExpression':
                const leftCondValue = evaluate(node.left, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                const rightCondValue = evaluate(node.right, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                result = !leftCondValue || rightCondValue;
                break;
            case 'BiconditionalExpression':
                const leftBicondValue = evaluate(node.left, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                const rightBicondValue = evaluate(node.right, variableAssignment, subexpressionValues, subexpressions, variablesSet);
                result = leftBicondValue === rightBicondValue;
                break;
            default:
                throw new Error('Unknown node type: ' + node.type);
        }

        const exprString = nodeToString(node);

        if (!subexpressions.includes(exprString) && !variablesSet.has(exprString)) {
            subexpressions.push(exprString);
        }

        subexpressionValues[exprString] = result;

        return result;
    }

    // Function to insert operator at cursor position
    function insertAtCursor(input, value) {
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const text = input.value;
        input.value = text.slice(0, start) + value + text.slice(end);
        input.selectionStart = input.selectionEnd = start + value.length;
        input.focus();
    }

    // Track the last focused input
    let lastFocusedInput = null;

    // Add focus event listeners to input fields
    const expressionInput1 = document.getElementById('expression-input');
    const expressionInput2 = document.getElementById('expression2-input');

    expressionInput1.addEventListener('focus', function() {
        lastFocusedInput = this;
    });

    expressionInput2.addEventListener('focus', function() {
        lastFocusedInput = this;
    });

    // Event listener for the operator buttons
    document.querySelectorAll('.operator-button').forEach(button => {
        button.addEventListener('click', function (event) {
            event.preventDefault();
            const operator = this.getAttribute('data-operator');
            let input = lastFocusedInput;
            if (input && (input.id === 'expression-input' || input.id === 'expression2-input')) {
                insertAtCursor(input, operator);
            } else {
                // If no input is focused yet, default to the first input
                input = document.getElementById('expression-input');
                input.focus();
                insertAtCursor(input, operator);
            }
        });
    });

    // Mode toggle functionality
    const modeRadios = document.querySelectorAll('input[name="mode"]');
    modeRadios.forEach(radio => {
        radio.addEventListener('change', function () {
            const mode = this.value;
            const expression2Container = document.getElementById('expression2-container');
            const equivalenceMessageDiv = document.getElementById('equivalence-message');
            if (mode === 'single') {
                expression2Container.style.display = 'none';
                equivalenceMessageDiv.textContent = '';
            } else {
                expression2Container.style.display = 'block';
            }
        });
    });

    // Event listener for the generate button
    document.getElementById('generate-button').addEventListener('click', function () {
        const mode = document.querySelector('input[name="mode"]:checked').value;
        const input1 = document.getElementById('expression-input').value.trim();
        const input2 = document.getElementById('expression2-input').value.trim();
        const errorMessageDiv = document.getElementById('error-message');
        const tableContainer = document.getElementById('table-container');
        const equivalenceMessageDiv = document.getElementById('equivalence-message');
        errorMessageDiv.textContent = '';
        tableContainer.innerHTML = '';
        equivalenceMessageDiv.textContent = '';

        if (!input1) {
            errorMessageDiv.textContent = 'Please enter a Boolean expression.';
            return;
        }

        if (mode === 'double' && !input2) {
            errorMessageDiv.textContent = 'Please enter both Boolean expressions.';
            return;
        }

        try {
            const ast1 = parse(input1);
            let ast2 = null;
            const variables = [];
            collectVariables(ast1, variables);

            if (mode === 'double') {
                ast2 = parse(input2);
                collectVariables(ast2, variables);
            }

            const variablesSet = new Set(variables);

            const assignments = generateTruthAssignments(variables);

            const subexpressions1 = [];
            const results = [];

            // For each assignment, evaluate the expressions
            let equivalent = true; // Assume equivalence initially

            assignments.forEach(assignment => {
                const subexpressionValues1 = {};
                const result1 = evaluate(ast1, assignment, subexpressionValues1, subexpressions1, variablesSet);

                if (mode === 'double') {
                    const subexpressionValues2 = {};
                    const result2 = evaluate(ast2, assignment, subexpressionValues2, [], variablesSet);

                    const isSame = result1 === result2;

                    if (!isSame) {
                        equivalent = false;
                    }

                    results.push({
                        assignment: assignment,
                        result1: result1,
                        result2: result2,
                        isSame: isSame
                    });
                } else {
                    results.push({
                        assignment: assignment,
                        result1: result1
                    });
                }
            });

            // Build the table
            const mainExpression1 = nodeToString(ast1);

            // Variables are already collected
            const headers = variables;

            // Create table
            const table = document.createElement('table');
            table.id = 'truth-table';

            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });

            // Add headers for expressions
            const th1 = document.createElement('th');
            th1.textContent = mainExpression1;
            headerRow.appendChild(th1);

            if (mode === 'double') {
                const mainExpression2 = nodeToString(ast2);
                const th2 = document.createElement('th');
                th2.textContent = mainExpression2;
                headerRow.appendChild(th2);

                const thSame = document.createElement('th');
                thSame.textContent = 'Same?';
                headerRow.appendChild(thSame);
            }

            table.appendChild(headerRow);

            // Create table rows
            results.forEach(result => {
                const row = document.createElement('tr');
                if (mode === 'double' && !result.isSame) {
                    row.classList.add('difference');
                }
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = result.assignment[header] ? 'T' : 'F';
                    row.appendChild(td);
                });
                // Add results
                const td1 = document.createElement('td');
                td1.textContent = result.result1 ? 'T' : 'F';
                row.appendChild(td1);

                if (mode === 'double') {
                    const td2 = document.createElement('td');
                    td2.textContent = result.result2 ? 'T' : 'F';
                    row.appendChild(td2);

                    const tdSame = document.createElement('td');
                    tdSame.textContent = result.isSame ? 'Yes' : 'No';
                    row.appendChild(tdSame);
                }
                table.appendChild(row);
            });

            // Add table to the container
            tableContainer.appendChild(table);

            // Display equivalence message if in double mode
            if (mode === 'double') {
                if (equivalent) {
                    equivalenceMessageDiv.textContent = 'The expressions are logically equivalent in all possible worlds.';
                    equivalenceMessageDiv.style.color = 'green';
                } else {
                    equivalenceMessageDiv.textContent = 'The expressions are not logically equivalent in all possible worlds.';
                    equivalenceMessageDiv.style.color = 'red';
                }
            }

        } catch (error) {
            errorMessageDiv.textContent = 'Error: ' + error.message;
        }
    });
</script>
</body>
</html>
